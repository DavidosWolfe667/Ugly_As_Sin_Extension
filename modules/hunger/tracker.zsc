class UaS_HungerTracker : Inventory {
	int energy;
	int hydro;
	int mouth;
	int mouth_calories;
	int mouth_fluid;
	bool drinking;

	default {
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.UNTOSSABLE;
		-INVENTORY.INVBAR;
	}

	override void DoEffect() {
		if (owner.health <= 0) { return; }
		Consume();
		BurnEnergy();
	}

	void BurnEnergy() {
		HDPlayerPawn o = HDPlayerPawn(owner);
		string debugmsg = "Fatigue %i, energy %i, hydro %i";
		if (o.beatcount > 0) { return; }
		if (energy <= 0 && hydro <= 0) { return; }

		// base drain
		energy = max(energy - 1, 0);
		hydro = max(hydro - 1, 0);

		// drain from fatigue
		// All this disabled by cvar
		if (UaS_HungerEnabled && o.fatigue > 0) {
			energy = max(energy - 1, 0);
			hydro = max(hydro - 1, 0);

			// fatigue recovery and additional drain
			if (energy > 0 && o.beatcounter % 7 == 0) {
				o.fatigue = max(o.fatigue - 1, 0);
				energy = max(energy - 1, 0);
				debugmsg = debugmsg.." recovered by energy ";
			}
			if (hydro > 0 && o.beatcounter % 4 == 0) {
				o.fatigue = max(o.fatigue - 1, 0);
				hydro = max(hydro - 1, 0);
				debugmsg = debugmsg.." recovered by hydro ";
			}
		}

		if(UaS_Debug & Hunger) { o.A_Log(string.format(debugmsg, o.fatigue, energy, hydro), true); }
	}

	void Consume() {
		if (mouthclear()) { return; }
		if (level.maptime % 12 == 0) {
			string snd;
			if (drinking) { snd="UaS/Sip"; }
			else { snd = "UaS/Chew"; }
			owner.A_StartSound(snd,
				CHAN_BODY, CHANF_OVERLAP,
				frandom[uas_hunger](0.4, 0.75), ATTN_STATIC,
				frandom[uas_hunger](0.9, 1.1));
			mouth--;
		}
		if (mouthclear()) {
			owner.A_StartSound("UaS/Swallow", CHAN_VOICE);
			energy += mouth_calories;
			hydro += mouth_fluid;
			mouth_calories = 0;
			mouth_fluid = 0;
			drinking = false;
			return;
		}
	}

	bool mouthclear() {
		return (mouth <= 0);
	}
}
